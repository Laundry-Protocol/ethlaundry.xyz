{"noir_version":"1.0.0-beta.18+99bb8b5cf33d7669adbdef096b12d80f30b4c0c9","hash":"6455232115145498476","abi":{"parameters":[{"name":"merkle_root","type":{"kind":"field"},"visibility":"public"},{"name":"nullifier","type":{"kind":"field"},"visibility":"public"},{"name":"recipient","type":{"kind":"field"},"visibility":"public"},{"name":"amount","type":{"kind":"field"},"visibility":"public"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"commitment_randomness","type":{"kind":"field"},"visibility":"private"},{"name":"merkle_path","type":{"kind":"array","length":20,"type":{"kind":"field"}},"visibility":"private"},{"name":"merkle_indices","type":{"kind":"array","length":20,"type":{"kind":"integer","sign":"unsigned","width":1}},"visibility":"private"}],"return_type":null,"error_types":{"12469291177396340830":{"error_kind":"string","string":"call to assert_max_bit_size"},"15764276373176857197":{"error_kind":"string","string":"Stack too deep"}}},"bytecode":"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","debug_symbols":"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","file_map":{"17":{"source":"use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\npub(crate) global PLO: Field = 53438638232309528389504892708671455233;\npub(crate) global PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n\n    #[test]\n    fn check_decompose_edge_cases() {\n        assert_eq(decompose(0), (0, 0));\n        assert_eq(decompose(TWO_POW_128 - 1), (TWO_POW_128 - 1, 0));\n        assert_eq(decompose(TWO_POW_128 + 1), (1, 1));\n        assert_eq(decompose(TWO_POW_128 * 2), (0, 2));\n        assert_eq(decompose(TWO_POW_128 * 2 + 0x1234567890), (0x1234567890, 2));\n    }\n\n    #[test]\n    fn check_decompose_large_values() {\n        let large_field = 0xffffffffffffffff;\n        let (lo, hi) = decompose(large_field);\n        assert_eq(large_field, lo + TWO_POW_128 * hi);\n\n        let large_value = large_field - TWO_POW_128;\n        let (lo2, hi2) = decompose(large_value);\n        assert_eq(large_value, lo2 + TWO_POW_128 * hi2);\n    }\n\n    #[test]\n    fn check_lt_comprehensive() {\n        assert(lt(0, 1));\n        assert(!lt(1, 0));\n        assert(!lt(0, 0));\n        assert(!lt(42, 42));\n\n        assert(lt(TWO_POW_128 - 1, TWO_POW_128));\n        assert(!lt(TWO_POW_128, TWO_POW_128 - 1));\n    }\n}\n","path":"std/field/bn254.nr"},"18":{"source":"pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting array will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime, static_assert};\n    use super::{\n        field_less_than, modulus_be_bits, modulus_be_bytes, modulus_le_bits, modulus_le_bytes,\n    };\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    // Updated test to account for Brillig restriction that radix must be greater than 2\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_brillig_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 1;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(\"radix must be greater than 1\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n\n    #[test]\n    unconstrained fn test_large_field_values_unconstrained() {\n        let large_field = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_field.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_field.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_field);\n\n        let radix_bytes: [u8; 8] = large_field.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_field);\n    }\n\n    #[test]\n    fn test_large_field_values() {\n        let large_val = 0xffffffffffffffff;\n\n        let bits: [u1; 64] = large_val.to_le_bits();\n        assert_eq(bits[0], 1);\n\n        let bytes: [u8; 8] = large_val.to_le_bytes();\n        assert_eq(Field::from_le_bytes::<8>(bytes), large_val);\n\n        let radix_bytes: [u8; 8] = large_val.to_le_radix(256);\n        assert_eq(Field::from_le_bytes::<8>(radix_bytes), large_val);\n    }\n\n    #[test]\n    fn test_decomposition_edge_cases() {\n        let zero_bits: [u1; 8] = 0.to_le_bits();\n        assert_eq(zero_bits, [0; 8]);\n\n        let zero_bytes: [u8; 8] = 0.to_le_bytes();\n        assert_eq(zero_bytes, [0; 8]);\n\n        let one_bits: [u1; 8] = 1.to_le_bits();\n        let expected: [u1; 8] = [1, 0, 0, 0, 0, 0, 0, 0];\n        assert_eq(one_bits, expected);\n\n        let pow2_bits: [u1; 8] = 4.to_le_bits();\n        let expected: [u1; 8] = [0, 0, 1, 0, 0, 0, 0, 0];\n        assert_eq(pow2_bits, expected);\n    }\n\n    #[test]\n    fn test_pow_32() {\n        assert_eq(2.pow_32(3), 8);\n        assert_eq(3.pow_32(2), 9);\n        assert_eq(5.pow_32(0), 1);\n        assert_eq(7.pow_32(1), 7);\n\n        assert_eq(2.pow_32(10), 1024);\n\n        assert_eq(0.pow_32(5), 0);\n        assert_eq(0.pow_32(0), 1);\n\n        assert_eq(1.pow_32(100), 1);\n    }\n\n    #[test]\n    fn test_sgn0() {\n        assert_eq(0.sgn0(), 0);\n        assert_eq(2.sgn0(), 0);\n        assert_eq(4.sgn0(), 0);\n        assert_eq(100.sgn0(), 0);\n\n        assert_eq(1.sgn0(), 1);\n        assert_eq(3.sgn0(), 1);\n        assert_eq(5.sgn0(), 1);\n        assert_eq(101.sgn0(), 1);\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 8 limbs\")]\n    fn test_bit_decomposition_overflow() {\n        // 8 bits can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u1; 8] = large_val.to_le_bits();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 4 limbs\")]\n    fn test_byte_decomposition_overflow() {\n        // 4 bytes can't represent large field values\n        let large_val = 0x1000000000000000;\n        let _: [u8; 4] = large_val.to_le_bytes();\n    }\n\n    #[test]\n    fn test_to_from_be_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 BE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_minus_1_bytes[32 - 1] > 0);\n            p_minus_1_bytes[32 - 1] -= 1;\n\n            let p_minus_1 = Field::from_be_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_be_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 BE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_be_bytes().as_array();\n            assert(p_plus_1_bytes[32 - 1] < 255);\n            p_plus_1_bytes[32 - 1] += 1;\n\n            let p_plus_1 = Field::from_be_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 BE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_be_bytes();\n            assert_eq(p_plus_1_converted_bytes[32 - 1], 1);\n            p_plus_1_converted_bytes[32 - 1] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_be_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_be_bytes().len(), 32);\n            let p = Field::from_be_bytes::<32>(modulus_be_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 BE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_be_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bytes_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this byte produces the expected 32 LE bytes for (modulus - 1)\n            let mut p_minus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_minus_1_bytes[0] > 0);\n            p_minus_1_bytes[0] -= 1;\n\n            let p_minus_1 = Field::from_le_bytes::<32>(p_minus_1_bytes);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 32 BE bytes produces the same bytes\n            let p_minus_1_converted_bytes: [u8; 32] = p_minus_1.to_le_bytes();\n            assert_eq(p_minus_1_converted_bytes, p_minus_1_bytes);\n\n            // checking that incrementing this byte produces 32 LE bytes for (modulus + 1)\n            let mut p_plus_1_bytes: [u8; 32] = modulus_le_bytes().as_array();\n            assert(p_plus_1_bytes[0] < 255);\n            p_plus_1_bytes[0] += 1;\n\n            let p_plus_1 = Field::from_le_bytes::<32>(p_plus_1_bytes);\n            assert_eq(p_plus_1, 1);\n\n            // checking that converting p_plus_1 to 32 LE bytes produces the same\n            // byte set to 1 as p_plus_1_bytes and otherwise zeroes\n            let mut p_plus_1_converted_bytes: [u8; 32] = p_plus_1.to_le_bytes();\n            assert_eq(p_plus_1_converted_bytes[0], 1);\n            p_plus_1_converted_bytes[0] = 0;\n            assert_eq(p_plus_1_converted_bytes, [0; 32]);\n\n            // checking that Field::from_le_bytes::<32> on the Field modulus produces 0\n            assert_eq(modulus_le_bytes().len(), 32);\n            let p = Field::from_le_bytes::<32>(modulus_le_bytes().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 32 LE bytes produces 32 zeroes\n            let p_bytes: [u8; 32] = 0.to_le_bytes();\n            assert_eq(p_bytes, [0; 32]);\n        }\n    }\n\n    /// Convert a little endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_le_bits<let N: u32>(bits: [u1; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bits().len(),\n            \"N must be less than or equal to modulus_le_bits().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    /// Convert a big endian bit array to a field element.\n    /// If the provided bit array overflows the field modulus then the Field will silently wrap around.\n    fn from_be_bits<let N: u32>(bits: [u1; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bits[N - 1 - i] as Field) * v;\n            v = v * 2;\n        }\n        result\n    }\n\n    #[test]\n    fn test_to_from_be_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 BE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_minus_1_bits[254 - 1] > 0);\n            p_minus_1_bits[254 - 1] -= 1;\n\n            let p_minus_1 = from_be_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_be_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 BE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_be_bits().as_array();\n            assert(p_plus_4_bits[254 - 3] < 1);\n            p_plus_4_bits[254 - 3] += 1;\n\n            let p_plus_4 = from_be_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 BE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_be_bits();\n            assert_eq(p_plus_4_converted_bits[254 - 3], 1);\n            p_plus_4_converted_bits[254 - 3] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_be_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_be_bits().len(), 254);\n            let p = from_be_bits::<254>(modulus_be_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 BE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_be_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n\n    #[test]\n    fn test_to_from_le_bits_bn254_edge_cases() {\n        if crate::compat::is_bn254() {\n            // checking that decrementing this bit produces the expected 254 LE bits for (modulus - 1)\n            let mut p_minus_1_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_minus_1_bits[0] > 0);\n            p_minus_1_bits[0] -= 1;\n\n            let p_minus_1 = from_le_bits::<254>(p_minus_1_bits);\n            assert_eq(p_minus_1 + 1, 0);\n\n            // checking that converting (modulus - 1) from and then to 254 BE bits produces the same bits\n            let p_minus_1_converted_bits: [u1; 254] = p_minus_1.to_le_bits();\n            assert_eq(p_minus_1_converted_bits, p_minus_1_bits);\n\n            // checking that incrementing this bit produces 254 LE bits for (modulus + 4)\n            let mut p_plus_4_bits: [u1; 254] = modulus_le_bits().as_array();\n            assert(p_plus_4_bits[2] < 1);\n            p_plus_4_bits[2] += 1;\n\n            let p_plus_4 = from_le_bits::<254>(p_plus_4_bits);\n            assert_eq(p_plus_4, 4);\n\n            // checking that converting p_plus_4 to 254 LE bits produces the same\n            // bit set to 1 as p_plus_4_bits and otherwise zeroes\n            let mut p_plus_4_converted_bits: [u1; 254] = p_plus_4.to_le_bits();\n            assert_eq(p_plus_4_converted_bits[2], 1);\n            p_plus_4_converted_bits[2] = 0;\n            assert_eq(p_plus_4_converted_bits, [0; 254]);\n\n            // checking that Field::from_le_bits::<254> on the Field modulus produces 0\n            assert_eq(modulus_le_bits().len(), 254);\n            let p = from_le_bits::<254>(modulus_le_bits().as_array());\n            assert_eq(p, 0);\n\n            // checking that converting 0 to 254 LE bytes produces 254 zeroes\n            let p_bits: [u1; 254] = 0.to_le_bits();\n            assert_eq(p_bits, [0; 254]);\n        }\n    }\n}\n","path":"std/field/mod.nr"},"19":{"source":"// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Decompose the input 'bn254 scalar' into two 128 bits limbs.\n// It is called 'unsafe' because it does not assert the limbs are 128 bits\n// Assuming the limbs are 128 bits:\n// Assert the decomposition does not overflow the field size.\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    // Check that the decomposition does not overflow the field size\n    let (a, b) = if xhi == crate::field::bn254::PHI {\n        (xlo, crate::field::bn254::PLO)\n    } else {\n        (xhi, crate::field::bn254::PHI)\n    };\n    crate::field::bn254::assert_lt(a, b);\n\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"51":{"source":"// Withdrawal Circuit for Laundry Cash (Production - Depth 20)\nuse dep::std::hash::pedersen_hash;\n\nglobal TREE_DEPTH: u32 = 20;\n\nfn main(\n    merkle_root: pub Field,\n    nullifier: pub Field,\n    recipient: pub Field,\n    amount: pub Field,\n    secret: Field,\n    commitment_randomness: Field,\n    merkle_path: [Field; 20],\n    merkle_indices: [u1; 20]\n) {\n    // Compute commitment\n    let commitment = pedersen_hash([amount, commitment_randomness]);\n\n    // Compute leaf\n    let leaf = pedersen_hash([commitment, secret]);\n\n    // Verify Merkle path\n    let mut current = leaf;\n    for i in 0..TREE_DEPTH {\n        let sibling = merkle_path[i];\n        let (left, right) = if merkle_indices[i] == 0 {\n            (current, sibling)\n        } else {\n            (sibling, current)\n        };\n        current = pedersen_hash([left, right]);\n    }\n    assert(current == merkle_root);\n\n    // Verify nullifier\n    let mut leaf_index: Field = 0;\n    let mut power: Field = 1;\n    for i in 0..TREE_DEPTH {\n        if merkle_indices[i] == 1 {\n            leaf_index += power;\n        }\n        power *= 2;\n    }\n    let computed_nullifier = pedersen_hash([secret, leaf_index]);\n    assert(computed_nullifier == nullifier);\n\n    // Bind public inputs\n    let _ = recipient;\n    let _ = amount;\n}\n","path":"/Users/jacelander/Downloads/hiddengem/circuits/withdrawal_v2/src/main.nr"}},"expression_width":{"Bounded":{"width":4}}}