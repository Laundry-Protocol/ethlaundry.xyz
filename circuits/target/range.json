{"noir_version":"0.36.0+801c71880ecf8386a26737a5d8bb5b4cb164b2ab","hash":16516332858230894157,"abi":{"parameters":[{"name":"commitment","type":{"kind":"field"},"visibility":"public"},{"name":"min_value","type":{"kind":"field"},"visibility":"public"},{"name":"balance","type":{"kind":"field"},"visibility":"private"},{"name":"randomness","type":{"kind":"field"},"visibility":"private"}],"return_type":null,"error_types":{}},"bytecode":"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","debug_symbols":"1d3djm1lmUfxe9nHHKz5fL7TW+l0DCKanRAwgJ10CPfetbt30WR/lFHqZ/TEWLLW+hc1HeSBDEb99OaPX//hr3/+/dtv//TdD29+9x8/vfnmu6++/PHtd98+ffXTm8f//k8//OXLb9999cOPX37/45vfnev+4s3X3/7x6b91//zFmz+9/ebrN7/b/PmLj1561Xl+7dWxv7w47k+8OB7R718cj46XX5yR+f7FGTu/fvF/fvHm+tf9vrOu5+877/zg+45/0593/pv+vOuf+n1nxfP3nXd88K30J7+VOe/fcT+uX38rT2+YT73hus7zn+4V1+NvfPd77/OLz+P+4PMXf/7Bn3/jz78eeuDSA6EHUg+UHmg98AoYn7ueX3zH+XBg9cDRAzceiMdrDPT/D+SHA5ceCD2QeqD0Q249oEkOTXIc/ZBvPJCa5NQkZ+CHnKkHNMmpSc7RD3n1gCY5Ncn1wA+5Lj2gSS5NcpV+yK0HNMmlSS59XZe+rluT3Jrk1td16+u6NcmtSW59Xbe+rluT3Jrk0df16Ot6NMmjSR59XY++rkeTPJrk0df16Ot6NcmrSV59Xa++rleTvJrk1df16ut6NcmrST76uj76uj6a5KNJPvq6Pvq6Pprko0k++ro++rq+Ncm3JvnW1/Wtr+tbk3xrkm99Xd/6ur41ybcm+Xro8/p6XHwh+ELyheJPuvkCF0Qe3BB5HP6k9Z19XZzpizN96VP7upIvcKYvzvQ1/EkvX+BMX5zp0Cf3FRdf4EwHZ/p15K8Xn3TzBc50cKaDq5zBb+/kTCdnOvntnfz2Ts50cqaT397Jb+/kTCdnuvjtXfz2Ls50caZfRwh78Unz27s408WZLn57F7+9mzPdnOnmt3fz27s5082Zbn57N7+9mzPdnOnht/fw23s408OZfh1J7MUnzW/v4UwPZ3r47T389l7O9HKml9/ey2/v5UwvZ3r9v+zMb+/lTC9n+vDb+/Db+3CmD2f6dcSxF580v70PZ/r4ggG/vQ+/vW/O9M2ZvvntffPb++ZM35zpm9/eN7+9b870rZmOh76943HxheALyReKP+nmC8MXli8c/qR5a+jiTF+c6Yvnhi7eG7o40xdnmsfDgtfDgufDwvfDfEDsn1AQ40z7hpiPiPmKmM+I+Y6YD4nxkljwlFjwlljwmFjwmljwnFjwnljwoFjwoljwpFjwpljwqFjwqljwrFjwrljwsFjwsljwtFjwtljwuFjwuljwvFjwvljwwFjwwljwxFjwxljwyFjwyljwzFjwzljw0Fjw0ljw1Fjw1ljw2FiMr3JzpnlvLHhwLHhxLHhyLHhzLHh0LHh1LHh2LHh3LHh4LHh5LHh6LHh7LHh8LHh9LHh+LHh/LHiALHiBLHiCLHiDLHiELHiFLHiGLHiHLHiILHiJLHiKLHiLLHiMLHiNLHiOLHiPLHmPLHmPLHmPLHmPLB/FnzT/3Ti8R5a8R5a8R5a8R5aX/1VXnGneI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veI0veIyveIyveIyveIyveI6tH8SfdfGH4wvKFw5+0vr2L98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98iK98ia98ia98ia98ia98j6UfxJN18YvrB84fAnrW/v5j2y5j2y5j2y5j2y5j2y5j2y5j2y5j2y5j2y5j2y/oxHFpu/LNzn5YW49vH+xXGd/mjh4gvBF5IvFF9ovjB8YfnC4Qu3XkjOdHKmkzOdnOnkTCdnOjnTyZlOznRy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nu7j6T7+Mj/+Mj+e7uPpPv4yv/1lfnu6b0/37S9znlR7mvB0357u21/mt7/MfVctfFctfFctfFctfFctHuUn2j/u8RPrJ46f4Jd5+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+K5a+q5a+q5a+q5a+q5aPspPtH/c4yfWTxw/wS/z9F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F219F21/Iyr1o9fnmDnvjwR1z7evziu0x9PjJ9YP3H8xM0nPuOqverE5SfCT6SfKD/h6W5Pd3u629Pdnu7xdI+nezzd4+keT/d4usfTPZ7u8XSPp3s93evpXk/3errX072e7vV0r6d7Pd3r6T6e7uPpPp7u4+k+nu7j6T6e7uPpPp7u4+m+Pd23p/v2dN+e7tvTfXu6b0/37em+Pd03p7seDz9x+YnwE+knyk+0nxg/sX7i+AlP9+Xpvjzdl6f78nRfnu7L0315ui9P9+Xpvjzd4ekOT3d4usPTHZ7u8HSHpzs83eHpDk93errT052e7vR0p6c7Pd3p6U5Pd3q609Ndnu7ydJenuzzd5en2rlp5V628q1beVSvvqpV31cq7auVdtfKuWnlXrbyrVt5VK++qlXfVyrtq5V218q5aeVetvKtW3lUr76qVd9XKu2rlXbXyrlp5V628q1beVSvvqpV31cq7auVdtfKuWnlXrbyrVt5VK++qlXfVyrtq5V218q5aeVetvKtW3lUr76qVd9XKu2rlXbXyrlp5V628q1beVSvvqpV31cq7au1dtfauWntXrb2r9vRRfqL9xPiJ9RPHT3i6vavW3lVr76q1d9Xau2rtXbX2rlp7V629q9beVWvvqrV31dq7au1dtfauWntXrb2r1t5Va++qtXfV2rtq7V219q5ae1etvavW3lVr76q1d9Xau2rtXbX2rlp7V629q9beVWvvqrV31dq7au1dtfauWntXrb2r1t5Va++qtXfV2rtq7V219q5ae1etvavW3lVr76q1d9Xau2rtXbX2rlp7V629q9beVWvvqrV31dq7au1dtfauWntXrb2r1t5Va++qtXfV2rtq7V219q5ae1etvavW3lVr76q1d9Xau2rtXbX2rlp7V629q9beVWvvqrV31dq7au1dtfauWntXrb2r1t5VG++qjXfVxrtq4121eZSfaD8xfmL9xPETnm7vqo131ca7auNdtfGu2nhXbbyrNt5VG++qjXfVxrtq41218a7aeFdtvKs23lUb76qNd9XGu2rjXbXxrtp4V228qzbeVRvvqo131ca7auNdtfGu2nhXbbyrNt5VG++qjXfVxrtq41218a7aeFdtvKs23lUb76qNd9XGu2rzOVetH79M7P3xu+ofelf/ve96+uIP37/95pu3f/79N9999eWPb7/79od3b328+49P/1OJe+f50x6Pxy+fFv2JH87M/f61s/vrl777dpN+ev3mT7/P+9fuVR9+ev/2T3/+9cv7q19u/f7Th376/tZP337GYyc+/PRDP/3+zZ9+X+9fex4f/n/m0/+04e/79GfSTlwffvr1Wz/95PNTPR/9ZCJe8dM/oOnnp6/+68vv3375h2++fvdXh3d/8K/ffvX8F4unL3/877/83x95evH/AA==","file_map":{"25":{"source":"use crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\nglobal TWO_POW_64: Field = 0x10000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(mut x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 64 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low_lower_64 = (x as u64) as Field;\n    x = (x - low_lower_64) / TWO_POW_64;\n    let low_upper_64 = (x as u64) as Field;\n\n    let high = (x - low_upper_64) / TWO_POW_64;\n    let low = low_upper_64 * TWO_POW_64 + low_lower_64;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nfn compute_lt(x: Field, y: Field, num_bytes: u32) -> bool {\n    let x_bytes: [u8; 32] = x.to_le_bytes();\n    let y_bytes: [u8; 32] = y.to_le_bytes();\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i];\n            let y_byte = y_bytes[num_bytes - 1 - i];\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\nfn compute_lte(x: Field, y: Field, num_bytes: u32) -> bool {\n    if x == y {\n        true\n    } else {\n        compute_lt(x, y, num_bytes)\n    }\n}\n\nunconstrained fn lt_32_hint(x: Field, y: Field) -> bool {\n    compute_lt(x, y, 32)\n}\n\nunconstrained fn lte_16_hint(x: Field, y: Field) -> bool {\n    compute_lte(x, y, 16)\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    unsafe {\n        let borrow = lte_16_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(compute_lt(b, a, 32));\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        compute_lt(b, a, 32)\n    } else if a == b {\n        false\n    } else {\n        // Take a hint of the comparison and verify it\n        unsafe {\n            if lt_32_hint(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{\n        decompose, compute_lt, assert_gt, gt, TWO_POW_128, compute_lte, PLO, PHI,\n    };\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    fn check_compute_lt() {\n        assert(compute_lt(0, 1, 16));\n        assert(compute_lt(0, 0x100, 16));\n        assert(compute_lt(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lt(0, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_compute_lte() {\n        assert(compute_lte(0, 1, 16));\n        assert(compute_lte(0, 0x100, 16));\n        assert(compute_lte(0x100, TWO_POW_128 - 1, 16));\n        assert(!compute_lte(0, TWO_POW_128, 16));\n\n        assert(compute_lte(0, 0, 16));\n        assert(compute_lte(0x100, 0x100, 16));\n        assert(compute_lte(TWO_POW_128 - 1, TWO_POW_128 - 1, 16));\n        assert(compute_lte(TWO_POW_128, TWO_POW_128, 16));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n","path":"std/field/bn254.nr"},"29":{"source":"pub mod poseidon;\npub mod mimc;\npub mod poseidon2;\npub mod keccak;\npub mod sha256;\npub mod sha512;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n// Kept for backwards compatibility\npub use sha256::{digest, sha256, sha256_compression, sha256_var};\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars)[0]\n}\n\n#[field(bn254)]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n// docs:start:keccak256\npub fn keccak256<let N: u32>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{\n    crate::hash::keccak::keccak256(input, message_size)\n}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<let N: u32>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: StructDefinition) -> Quoted {\n    let name = quote { Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: std::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher<H>\nwhere\n    H: Hasher,\n{\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n","path":"std/hash/mod.nr"},"73":{"source":"// Range Proof Circuit\n// Proves that a committed value is >= a minimum amount (typically transfer amount)\n// Uses bit decomposition for efficient range checking\n//\n// Public Inputs:\n//   - commitment: Pedersen commitment to the balance\n//   - min_value: Minimum value the balance must be (e.g., transfer amount)\n//\n// Private Inputs:\n//   - balance: The actual balance value\n//   - randomness: Randomness used in the commitment\n\nuse std::hash::pedersen_hash;\n\n// Maximum bit width for values (64 bits = ~18 ETH max in wei)\nglobal MAX_BITS: u32 = 64;\n\n// Main circuit function\nfn main(\n    // Public inputs\n    commitment: pub Field,\n    min_value: pub Field,\n    // Private inputs\n    balance: Field,\n    randomness: Field\n) {\n    // 1. Verify the commitment opens to the claimed balance\n    let computed_commitment = pedersen_hash([balance, randomness]);\n    assert(computed_commitment == commitment, \"Invalid commitment\");\n\n    // 2. Verify balance >= min_value using bit decomposition\n    // balance - min_value must be non-negative (in range [0, 2^64))\n    let difference = balance - min_value;\n\n    // Decompose difference into bits to prove it's non-negative\n    let bits = decompose_to_bits(difference);\n\n    // Verify decomposition is correct\n    let recomposed = recompose_from_bits(bits);\n    assert(recomposed == difference, \"Invalid bit decomposition\");\n\n    // Additional check: balance must be in valid range\n    let balance_bits = decompose_to_bits(balance);\n    let balance_recomposed = recompose_from_bits(balance_bits);\n    assert(balance_recomposed == balance, \"Balance out of range\");\n}\n\n// Decompose a field element into 64 bits\n// Constrains each bit to be 0 or 1\nfn decompose_to_bits(value: Field) -> [u1; 64] {\n    let mut bits: [u1; 64] = [0; 64];\n    let value_as_int = value as u64;\n\n    for i in 0..MAX_BITS {\n        let shift_amount = i as u8;\n        bits[i] = ((value_as_int >> shift_amount) & 1) as u1;\n    }\n\n    bits\n}\n\n// Recompose field element from bits\nfn recompose_from_bits(bits: [u1; 64]) -> Field {\n    let mut result: Field = 0;\n    let mut power: Field = 1;\n\n    for i in 0..MAX_BITS {\n        if bits[i] == 1 {\n            result += power;\n        }\n        power *= 2;\n    }\n\n    result\n}\n\n// Verify value fits within max_bits range\nfn efficient_range_check(value: Field, _max_bits: u32) -> bool {\n    let value_as_u64 = value as u64;\n    // Verify round-trip: if value fits in u64, it's in range\n    let back_to_field = value_as_u64 as Field;\n    back_to_field == value\n}\n\n// Bulletproofs-style range proof structure\n// More efficient for larger ranges\nstruct RangeProofWitness {\n    value: Field,\n    randomness: Field,\n    value_bits: [u1; 64],\n}\n\nimpl RangeProofWitness {\n    fn verify(self, commitment: Field) -> bool {\n        // Verify commitment\n        let computed = pedersen_hash([self.value, self.randomness]);\n        let commitment_valid = computed == commitment;\n\n        // Verify bit decomposition\n        let recomposed = recompose_from_bits(self.value_bits);\n        let bits_valid = recomposed == self.value;\n\n        commitment_valid & bits_valid\n    }\n}\n\n#[test]\nfn test_bit_decomposition() {\n    // Test zero\n    let bits_zero = decompose_to_bits(0);\n    assert(recompose_from_bits(bits_zero) == 0);\n\n    // Test one\n    let bits_one = decompose_to_bits(1);\n    assert(recompose_from_bits(bits_one) == 1);\n\n    // Test power of 2\n    let bits_256 = decompose_to_bits(256);\n    assert(recompose_from_bits(bits_256) == 256);\n\n    // Test large value\n    let large: Field = 1000000000000000000; // 1 ETH in wei\n    let bits_large = decompose_to_bits(large);\n    assert(recompose_from_bits(bits_large) == large);\n}\n\n#[test]\nfn test_range_check() {\n    // Value within range\n    let value: Field = 1000;\n    assert(efficient_range_check(value, 64));\n\n    // Zero is valid\n    assert(efficient_range_check(0, 64));\n\n    // Max 64-bit value is valid\n    let max_64: Field = 18446744073709551615; // 2^64 - 1\n    assert(efficient_range_check(max_64, 64));\n}\n\n#[test]\nfn test_range_proof_basic() {\n    let balance: Field = 1000;\n    let min_value: Field = 500;\n    let randomness: Field = 12345;\n\n    let _commitment = pedersen_hash([balance, randomness]);\n\n    // balance - min_value = 500, which should be decomposable\n    let difference = balance - min_value;\n    let bits = decompose_to_bits(difference);\n    let recomposed = recompose_from_bits(bits);\n\n    assert(recomposed == difference);\n}\n","path":"/Users/jacelander/Downloads/hiddengem/circuits/range/src/main.nr"}},"names":["main"],"brillig_names":["decompose_hint","directive_integer_quotient","directive_invert"]}